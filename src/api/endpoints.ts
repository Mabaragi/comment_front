/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * API Documentation
 * API for my project
 * OpenAPI spec version: v1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  CommentsSummary,
  CrawlerEpisodeCommentList200,
  CrawlerEpisodeCommentListParams,
  CrawlerSeriesEpisodeList200,
  CrawlerSeriesEpisodeListParams,
  CrawlerSeriesList200,
  CrawlerSeriesListParams,
  CustomTokenObtainPair,
  CustomUser,
  Episode,
  EpisodeCreateResponse,
  Series,
  SeriesCreate,
  TokenObtainPair,
  TokenRefresh,
} from './schemas';

import { axiosInstance } from './axiosInstance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
  T,
>() => T extends Y ? 1 : 2
  ? A
  : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    P
  >;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object
        ? NonReadonly<NonNullable<T[P]>>
        : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

/**
 * ÌäπÏ†ï ÏãúÎ¶¨Ï¶àÏùò ÏóêÌîºÏÜåÎìúÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const crawlerEpisodeRead = (productId: string, signal?: AbortSignal) => {
  return axiosInstance<Episode>({
    url: `/crawler/episode/${productId}/`,
    method: 'GET',
    signal,
  });
};

export const getCrawlerEpisodeReadQueryKey = (productId: string) => {
  return [`/crawler/episode/${productId}/`] as const;
};

export const getCrawlerEpisodeReadQueryOptions = <
  TData = Awaited<ReturnType<typeof crawlerEpisodeRead>>,
  TError = void,
>(
  productId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerEpisodeRead>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCrawlerEpisodeReadQueryKey(productId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof crawlerEpisodeRead>>
  > = ({ signal }) => crawlerEpisodeRead(productId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!productId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof crawlerEpisodeRead>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CrawlerEpisodeReadQueryResult = NonNullable<
  Awaited<ReturnType<typeof crawlerEpisodeRead>>
>;
export type CrawlerEpisodeReadQueryError = void;

export function useCrawlerEpisodeRead<
  TData = Awaited<ReturnType<typeof crawlerEpisodeRead>>,
  TError = void,
>(
  productId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerEpisodeRead>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof crawlerEpisodeRead>>,
          TError,
          Awaited<ReturnType<typeof crawlerEpisodeRead>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCrawlerEpisodeRead<
  TData = Awaited<ReturnType<typeof crawlerEpisodeRead>>,
  TError = void,
>(
  productId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerEpisodeRead>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof crawlerEpisodeRead>>,
          TError,
          Awaited<ReturnType<typeof crawlerEpisodeRead>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCrawlerEpisodeRead<
  TData = Awaited<ReturnType<typeof crawlerEpisodeRead>>,
  TError = void,
>(
  productId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerEpisodeRead>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useCrawlerEpisodeRead<
  TData = Awaited<ReturnType<typeof crawlerEpisodeRead>>,
  TError = void,
>(
  productId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerEpisodeRead>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCrawlerEpisodeReadQueryOptions(productId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏóêÌîºÏÜåÎìú ÎåìÍ∏Ä Î™©Î°ùÏùÑ Ï°∞ÌöåÌïòÎäî API Î∑∞ÏûÖÎãàÎã§.
 */
export const crawlerEpisodeCommentList = (
  productId: string,
  params?: CrawlerEpisodeCommentListParams,
  signal?: AbortSignal,
) => {
  return axiosInstance<CrawlerEpisodeCommentList200>({
    url: `/crawler/episode/${productId}/comment`,
    method: 'GET',
    params,
    signal,
  });
};

export const getCrawlerEpisodeCommentListQueryKey = (
  productId: string,
  params?: CrawlerEpisodeCommentListParams,
) => {
  return [
    `/crawler/episode/${productId}/comment`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCrawlerEpisodeCommentListQueryOptions = <
  TData = Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
  TError = unknown,
>(
  productId: string,
  params?: CrawlerEpisodeCommentListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCrawlerEpisodeCommentListQueryKey(productId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof crawlerEpisodeCommentList>>
  > = ({ signal }) => crawlerEpisodeCommentList(productId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!productId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CrawlerEpisodeCommentListQueryResult = NonNullable<
  Awaited<ReturnType<typeof crawlerEpisodeCommentList>>
>;
export type CrawlerEpisodeCommentListQueryError = unknown;

export function useCrawlerEpisodeCommentList<
  TData = Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
  TError = unknown,
>(
  productId: string,
  params: undefined | CrawlerEpisodeCommentListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
          TError,
          Awaited<ReturnType<typeof crawlerEpisodeCommentList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCrawlerEpisodeCommentList<
  TData = Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
  TError = unknown,
>(
  productId: string,
  params?: CrawlerEpisodeCommentListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
          TError,
          Awaited<ReturnType<typeof crawlerEpisodeCommentList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCrawlerEpisodeCommentList<
  TData = Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
  TError = unknown,
>(
  productId: string,
  params?: CrawlerEpisodeCommentListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useCrawlerEpisodeCommentList<
  TData = Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
  TError = unknown,
>(
  productId: string,
  params?: CrawlerEpisodeCommentListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerEpisodeCommentList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCrawlerEpisodeCommentListQueryOptions(
    productId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏóêÌîºÏÜåÎìúÏùò ÎåìÍ∏ÄÏùÑ ÌÅ¨Î°§ÎßÅÌïòÏó¨ dbÏóê Ï†ÄÏû•Ìï©ÎãàÎã§.
 */
export const crawlerEpisodeCommentCrawlCreate = (
  productId: string,
  signal?: AbortSignal,
) => {
  return axiosInstance<EpisodeCreateResponse>({
    url: `/crawler/episode/${productId}/comment/crawl`,
    method: 'POST',
    signal,
  });
};

export const getCrawlerEpisodeCommentCrawlCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof crawlerEpisodeCommentCrawlCreate>>,
    TError,
    { productId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof crawlerEpisodeCommentCrawlCreate>>,
  TError,
  { productId: string },
  TContext
> => {
  const mutationKey = ['crawlerEpisodeCommentCrawlCreate'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof crawlerEpisodeCommentCrawlCreate>>,
    { productId: string }
  > = (props) => {
    const { productId } = props ?? {};

    return crawlerEpisodeCommentCrawlCreate(productId);
  };

  return { mutationFn, ...mutationOptions };
};

export type CrawlerEpisodeCommentCrawlCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof crawlerEpisodeCommentCrawlCreate>>
>;

export type CrawlerEpisodeCommentCrawlCreateMutationError = unknown;

export const useCrawlerEpisodeCommentCrawlCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof crawlerEpisodeCommentCrawlCreate>>,
      TError,
      { productId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof crawlerEpisodeCommentCrawlCreate>>,
  TError,
  { productId: string },
  TContext
> => {
  const mutationOptions =
    getCrawlerEpisodeCommentCrawlCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve a list of series
 */
export const crawlerSeriesList = (
  params?: CrawlerSeriesListParams,
  signal?: AbortSignal,
) => {
  return axiosInstance<CrawlerSeriesList200>({
    url: `/crawler/series/`,
    method: 'GET',
    params,
    signal,
  });
};

export const getCrawlerSeriesListQueryKey = (
  params?: CrawlerSeriesListParams,
) => {
  return [`/crawler/series/`, ...(params ? [params] : [])] as const;
};

export const getCrawlerSeriesListQueryOptions = <
  TData = Awaited<ReturnType<typeof crawlerSeriesList>>,
  TError = unknown,
>(
  params?: CrawlerSeriesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesList>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCrawlerSeriesListQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof crawlerSeriesList>>
  > = ({ signal }) => crawlerSeriesList(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof crawlerSeriesList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CrawlerSeriesListQueryResult = NonNullable<
  Awaited<ReturnType<typeof crawlerSeriesList>>
>;
export type CrawlerSeriesListQueryError = unknown;

export function useCrawlerSeriesList<
  TData = Awaited<ReturnType<typeof crawlerSeriesList>>,
  TError = unknown,
>(
  params: undefined | CrawlerSeriesListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof crawlerSeriesList>>,
          TError,
          Awaited<ReturnType<typeof crawlerSeriesList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCrawlerSeriesList<
  TData = Awaited<ReturnType<typeof crawlerSeriesList>>,
  TError = unknown,
>(
  params?: CrawlerSeriesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof crawlerSeriesList>>,
          TError,
          Awaited<ReturnType<typeof crawlerSeriesList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCrawlerSeriesList<
  TData = Awaited<ReturnType<typeof crawlerSeriesList>>,
  TError = unknown,
>(
  params?: CrawlerSeriesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useCrawlerSeriesList<
  TData = Awaited<ReturnType<typeof crawlerSeriesList>>,
  TError = unknown,
>(
  params?: CrawlerSeriesListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCrawlerSeriesListQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a series
 */
export const crawlerSeriesCrawlCreate = (
  seriesCreate: SeriesCreate,
  signal?: AbortSignal,
) => {
  return axiosInstance<Series>({
    url: `/crawler/series/crawl/`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: seriesCreate,
    signal,
  });
};

export const getCrawlerSeriesCrawlCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof crawlerSeriesCrawlCreate>>,
    TError,
    { data: SeriesCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof crawlerSeriesCrawlCreate>>,
  TError,
  { data: SeriesCreate },
  TContext
> => {
  const mutationKey = ['crawlerSeriesCrawlCreate'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof crawlerSeriesCrawlCreate>>,
    { data: SeriesCreate }
  > = (props) => {
    const { data } = props ?? {};

    return crawlerSeriesCrawlCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CrawlerSeriesCrawlCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof crawlerSeriesCrawlCreate>>
>;
export type CrawlerSeriesCrawlCreateMutationBody = SeriesCreate;
export type CrawlerSeriesCrawlCreateMutationError = unknown;

export const useCrawlerSeriesCrawlCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof crawlerSeriesCrawlCreate>>,
      TError,
      { data: SeriesCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof crawlerSeriesCrawlCreate>>,
  TError,
  { data: SeriesCreate },
  TContext
> => {
  const mutationOptions = getCrawlerSeriesCrawlCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve a series by ID
 */
export const crawlerSeriesRead = (seriesId: string, signal?: AbortSignal) => {
  return axiosInstance<Series>({
    url: `/crawler/series/${seriesId}/`,
    method: 'GET',
    signal,
  });
};

export const getCrawlerSeriesReadQueryKey = (seriesId: string) => {
  return [`/crawler/series/${seriesId}/`] as const;
};

export const getCrawlerSeriesReadQueryOptions = <
  TData = Awaited<ReturnType<typeof crawlerSeriesRead>>,
  TError = void,
>(
  seriesId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesRead>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCrawlerSeriesReadQueryKey(seriesId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof crawlerSeriesRead>>
  > = ({ signal }) => crawlerSeriesRead(seriesId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!seriesId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof crawlerSeriesRead>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CrawlerSeriesReadQueryResult = NonNullable<
  Awaited<ReturnType<typeof crawlerSeriesRead>>
>;
export type CrawlerSeriesReadQueryError = void;

export function useCrawlerSeriesRead<
  TData = Awaited<ReturnType<typeof crawlerSeriesRead>>,
  TError = void,
>(
  seriesId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesRead>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof crawlerSeriesRead>>,
          TError,
          Awaited<ReturnType<typeof crawlerSeriesRead>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCrawlerSeriesRead<
  TData = Awaited<ReturnType<typeof crawlerSeriesRead>>,
  TError = void,
>(
  seriesId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesRead>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof crawlerSeriesRead>>,
          TError,
          Awaited<ReturnType<typeof crawlerSeriesRead>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCrawlerSeriesRead<
  TData = Awaited<ReturnType<typeof crawlerSeriesRead>>,
  TError = void,
>(
  seriesId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesRead>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useCrawlerSeriesRead<
  TData = Awaited<ReturnType<typeof crawlerSeriesRead>>,
  TError = void,
>(
  seriesId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesRead>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCrawlerSeriesReadQueryOptions(seriesId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏóêÌîºÏÜåÎìú Î™©Î°ùÏùÑ Ï°∞ÌöåÌïòÎäî API Î∑∞ÏûÖÎãàÎã§.
 */
export const crawlerSeriesEpisodeList = (
  seriesId: string,
  params?: CrawlerSeriesEpisodeListParams,
  signal?: AbortSignal,
) => {
  return axiosInstance<CrawlerSeriesEpisodeList200>({
    url: `/crawler/series/${seriesId}/episode/`,
    method: 'GET',
    params,
    signal,
  });
};

export const getCrawlerSeriesEpisodeListQueryKey = (
  seriesId: string,
  params?: CrawlerSeriesEpisodeListParams,
) => {
  return [
    `/crawler/series/${seriesId}/episode/`,
    ...(params ? [params] : []),
  ] as const;
};

export const getCrawlerSeriesEpisodeListQueryOptions = <
  TData = Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
  TError = unknown,
>(
  seriesId: string,
  params?: CrawlerSeriesEpisodeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getCrawlerSeriesEpisodeListQueryKey(seriesId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>
  > = ({ signal }) => crawlerSeriesEpisodeList(seriesId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!seriesId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CrawlerSeriesEpisodeListQueryResult = NonNullable<
  Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>
>;
export type CrawlerSeriesEpisodeListQueryError = unknown;

export function useCrawlerSeriesEpisodeList<
  TData = Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
  TError = unknown,
>(
  seriesId: string,
  params: undefined | CrawlerSeriesEpisodeListParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
          TError,
          Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCrawlerSeriesEpisodeList<
  TData = Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
  TError = unknown,
>(
  seriesId: string,
  params?: CrawlerSeriesEpisodeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
          TError,
          Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCrawlerSeriesEpisodeList<
  TData = Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
  TError = unknown,
>(
  seriesId: string,
  params?: CrawlerSeriesEpisodeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useCrawlerSeriesEpisodeList<
  TData = Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
  TError = unknown,
>(
  seriesId: string,
  params?: CrawlerSeriesEpisodeListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof crawlerSeriesEpisodeList>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCrawlerSeriesEpisodeListQueryOptions(
    seriesId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÏóêÌîºÏÜåÎìúÎ•º ÌÅ¨Î°§ÎßÅÌïòÏó¨ dbÏóê Ï†ÄÏû•Ìï©ÎãàÎã§.
 */
export const crawlerSeriesEpisodeCrawlCreate = (
  seriesId: string,
  signal?: AbortSignal,
) => {
  return axiosInstance<EpisodeCreateResponse>({
    url: `/crawler/series/${seriesId}/episode/crawl`,
    method: 'POST',
    signal,
  });
};

export const getCrawlerSeriesEpisodeCrawlCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof crawlerSeriesEpisodeCrawlCreate>>,
    TError,
    { seriesId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof crawlerSeriesEpisodeCrawlCreate>>,
  TError,
  { seriesId: string },
  TContext
> => {
  const mutationKey = ['crawlerSeriesEpisodeCrawlCreate'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof crawlerSeriesEpisodeCrawlCreate>>,
    { seriesId: string }
  > = (props) => {
    const { seriesId } = props ?? {};

    return crawlerSeriesEpisodeCrawlCreate(seriesId);
  };

  return { mutationFn, ...mutationOptions };
};

export type CrawlerSeriesEpisodeCrawlCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof crawlerSeriesEpisodeCrawlCreate>>
>;

export type CrawlerSeriesEpisodeCrawlCreateMutationError = unknown;

export const useCrawlerSeriesEpisodeCrawlCreate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof crawlerSeriesEpisodeCrawlCreate>>,
      TError,
      { seriesId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof crawlerSeriesEpisodeCrawlCreate>>,
  TError,
  { seriesId: string },
  TContext
> => {
  const mutationOptions =
    getCrawlerSeriesEpisodeCrawlCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎåìÍ∏Ä Í∞êÏ†ï Î∂ÑÏÑù Í≤∞Í≥º ÏÇ≠Ï†ú
 */
export const llmApiEmotionAnalysisDeleteDelete = (commentId: string) => {
  return axiosInstance<void>({
    url: `/llm/api/emotion-analysis/${commentId}/delete/`,
    method: 'DELETE',
  });
};

export const getLlmApiEmotionAnalysisDeleteDeleteMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof llmApiEmotionAnalysisDeleteDelete>>,
    TError,
    { commentId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof llmApiEmotionAnalysisDeleteDelete>>,
  TError,
  { commentId: string },
  TContext
> => {
  const mutationKey = ['llmApiEmotionAnalysisDeleteDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof llmApiEmotionAnalysisDeleteDelete>>,
    { commentId: string }
  > = (props) => {
    const { commentId } = props ?? {};

    return llmApiEmotionAnalysisDeleteDelete(commentId);
  };

  return { mutationFn, ...mutationOptions };
};

export type LlmApiEmotionAnalysisDeleteDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof llmApiEmotionAnalysisDeleteDelete>>
>;

export type LlmApiEmotionAnalysisDeleteDeleteMutationError = void;

export const useLlmApiEmotionAnalysisDeleteDelete = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof llmApiEmotionAnalysisDeleteDelete>>,
      TError,
      { commentId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof llmApiEmotionAnalysisDeleteDelete>>,
  TError,
  { commentId: string },
  TContext
> => {
  const mutationOptions =
    getLlmApiEmotionAnalysisDeleteDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎåìÍ∏Ä Í∞êÏ†ï Î∂ÑÏÑù Ïã§Ìñâ
 * @summary ÏóêÌîºÏÜåÎìúÏùò ÎØ∏Ï≤òÎ¶¨ ÎåìÍ∏ÄÎì§Ïóê ÎåÄÌï¥ Í∞êÏ†ï Î∂ÑÏÑùÏùÑ ÏàòÌñâÌï©ÎãàÎã§.
 */
export const llmApiEmotionAnalysisPartialUpdate = (episodeId: string) => {
  return axiosInstance<void>({
    url: `/llm/api/emotion-analysis/${episodeId}/`,
    method: 'PATCH',
  });
};

export const getLlmApiEmotionAnalysisPartialUpdateMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof llmApiEmotionAnalysisPartialUpdate>>,
    TError,
    { episodeId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof llmApiEmotionAnalysisPartialUpdate>>,
  TError,
  { episodeId: string },
  TContext
> => {
  const mutationKey = ['llmApiEmotionAnalysisPartialUpdate'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof llmApiEmotionAnalysisPartialUpdate>>,
    { episodeId: string }
  > = (props) => {
    const { episodeId } = props ?? {};

    return llmApiEmotionAnalysisPartialUpdate(episodeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type LlmApiEmotionAnalysisPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof llmApiEmotionAnalysisPartialUpdate>>
>;

export type LlmApiEmotionAnalysisPartialUpdateMutationError = void;

/**
 * @summary ÏóêÌîºÏÜåÎìúÏùò ÎØ∏Ï≤òÎ¶¨ ÎåìÍ∏ÄÎì§Ïóê ÎåÄÌï¥ Í∞êÏ†ï Î∂ÑÏÑùÏùÑ ÏàòÌñâÌï©ÎãàÎã§.
 */
export const useLlmApiEmotionAnalysisPartialUpdate = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof llmApiEmotionAnalysisPartialUpdate>>,
      TError,
      { episodeId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof llmApiEmotionAnalysisPartialUpdate>>,
  TError,
  { episodeId: string },
  TContext
> => {
  const mutationOptions =
    getLlmApiEmotionAnalysisPartialUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎåìÍ∏Ä ÏöîÏïΩ Î™©Î°ù Ï°∞Ìöå
 * @summary ÌäπÏ†ï ÏóêÌîºÏÜåÎìúÏùò Î™®Îì† ÎåìÍ∏Ä ÏöîÏïΩ Í≤∞Í≥ºÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */
export const llmApiSummaryAnalysisRead = (
  episodeId: string,
  signal?: AbortSignal,
) => {
  return axiosInstance<CommentsSummary[]>({
    url: `/llm/api/summary-analysis/${episodeId}/`,
    method: 'GET',
    signal,
  });
};

export const getLlmApiSummaryAnalysisReadQueryKey = (episodeId: string) => {
  return [`/llm/api/summary-analysis/${episodeId}/`] as const;
};

export const getLlmApiSummaryAnalysisReadQueryOptions = <
  TData = Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
  TError = void,
>(
  episodeId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getLlmApiSummaryAnalysisReadQueryKey(episodeId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>
  > = ({ signal }) => llmApiSummaryAnalysisRead(episodeId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!episodeId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LlmApiSummaryAnalysisReadQueryResult = NonNullable<
  Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>
>;
export type LlmApiSummaryAnalysisReadQueryError = void;

export function useLlmApiSummaryAnalysisRead<
  TData = Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
  TError = void,
>(
  episodeId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
          TError,
          Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLlmApiSummaryAnalysisRead<
  TData = Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
  TError = void,
>(
  episodeId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
          TError,
          Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLlmApiSummaryAnalysisRead<
  TData = Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
  TError = void,
>(
  episodeId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ÌäπÏ†ï ÏóêÌîºÏÜåÎìúÏùò Î™®Îì† ÎåìÍ∏Ä ÏöîÏïΩ Í≤∞Í≥ºÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
 */

export function useLlmApiSummaryAnalysisRead<
  TData = Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
  TError = void,
>(
  episodeId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof llmApiSummaryAnalysisRead>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLlmApiSummaryAnalysisReadQueryOptions(
    episodeId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ÎåìÍ∏Ä ÏöîÏïΩ ÏÉùÏÑ±
 * @summary ÏóêÌîºÏÜåÎìúÏùò ÎåìÍ∏ÄÎì§ÏùÑ ÏöîÏïΩÌïòÏó¨ ÏÉàÎ°úÏö¥ ÏöîÏïΩ Í≤∞Í≥ºÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const llmApiSummaryAnalysisCreate = (
  episodeId: string,
  signal?: AbortSignal,
) => {
  return axiosInstance<CommentsSummary>({
    url: `/llm/api/summary-analysis/${episodeId}/`,
    method: 'POST',
    signal,
  });
};

export const getLlmApiSummaryAnalysisCreateMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof llmApiSummaryAnalysisCreate>>,
    TError,
    { episodeId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof llmApiSummaryAnalysisCreate>>,
  TError,
  { episodeId: string },
  TContext
> => {
  const mutationKey = ['llmApiSummaryAnalysisCreate'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof llmApiSummaryAnalysisCreate>>,
    { episodeId: string }
  > = (props) => {
    const { episodeId } = props ?? {};

    return llmApiSummaryAnalysisCreate(episodeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type LlmApiSummaryAnalysisCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof llmApiSummaryAnalysisCreate>>
>;

export type LlmApiSummaryAnalysisCreateMutationError = void;

/**
 * @summary ÏóêÌîºÏÜåÎìúÏùò ÎåìÍ∏ÄÎì§ÏùÑ ÏöîÏïΩÌïòÏó¨ ÏÉàÎ°úÏö¥ ÏöîÏïΩ Í≤∞Í≥ºÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 */
export const useLlmApiSummaryAnalysisCreate = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof llmApiSummaryAnalysisCreate>>,
      TError,
      { episodeId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof llmApiSummaryAnalysisCreate>>,
  TError,
  { episodeId: string },
  TContext
> => {
  const mutationOptions =
    getLlmApiSummaryAnalysisCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * ÎåìÍ∏Ä ÏöîÏïΩ Ï†ÑÏ≤¥ ÏÇ≠Ï†ú
 * @summary ÌäπÏ†ï ÏóêÌîºÏÜåÎìúÏùò Î™®Îì† ÎåìÍ∏Ä ÏöîÏïΩ Í≤∞Í≥ºÎ•º ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const llmApiSummaryAnalysisDelete = (episodeId: string) => {
  return axiosInstance<void>({
    url: `/llm/api/summary-analysis/${episodeId}/`,
    method: 'DELETE',
  });
};

export const getLlmApiSummaryAnalysisDeleteMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof llmApiSummaryAnalysisDelete>>,
    TError,
    { episodeId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof llmApiSummaryAnalysisDelete>>,
  TError,
  { episodeId: string },
  TContext
> => {
  const mutationKey = ['llmApiSummaryAnalysisDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof llmApiSummaryAnalysisDelete>>,
    { episodeId: string }
  > = (props) => {
    const { episodeId } = props ?? {};

    return llmApiSummaryAnalysisDelete(episodeId);
  };

  return { mutationFn, ...mutationOptions };
};

export type LlmApiSummaryAnalysisDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof llmApiSummaryAnalysisDelete>>
>;

export type LlmApiSummaryAnalysisDeleteMutationError = void;

/**
 * @summary ÌäπÏ†ï ÏóêÌîºÏÜåÎìúÏùò Î™®Îì† ÎåìÍ∏Ä ÏöîÏïΩ Í≤∞Í≥ºÎ•º ÏÇ≠Ï†úÌï©ÎãàÎã§.
 */
export const useLlmApiSummaryAnalysisDelete = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof llmApiSummaryAnalysisDelete>>,
      TError,
      { episodeId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof llmApiSummaryAnalysisDelete>>,
  TError,
  { episodeId: string },
  TContext
> => {
  const mutationOptions =
    getLlmApiSummaryAnalysisDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Î°úÍ∑∏Ïù∏ ÌõÑ access/refresh ÌÜ†ÌÅ∞ Î∞òÌôò
 */
export const tokenCreate = (
  tokenObtainPair: TokenObtainPair,
  signal?: AbortSignal,
) => {
  return axiosInstance<CustomTokenObtainPair>({
    url: `/token/`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: tokenObtainPair,
    signal,
  });
};

export const getTokenCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tokenCreate>>,
    TError,
    { data: TokenObtainPair },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof tokenCreate>>,
  TError,
  { data: TokenObtainPair },
  TContext
> => {
  const mutationKey = ['tokenCreate'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tokenCreate>>,
    { data: TokenObtainPair }
  > = (props) => {
    const { data } = props ?? {};

    return tokenCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type TokenCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof tokenCreate>>
>;
export type TokenCreateMutationBody = TokenObtainPair;
export type TokenCreateMutationError = unknown;

export const useTokenCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tokenCreate>>,
      TError,
      { data: TokenObtainPair },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tokenCreate>>,
  TError,
  { data: TokenObtainPair },
  TContext
> => {
  const mutationOptions = getTokenCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 */
export const tokenRefreshCreate = (
  tokenRefresh: NonReadonly<TokenRefresh>,
  signal?: AbortSignal,
) => {
  return axiosInstance<TokenRefresh>({
    url: `/token/refresh/`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: tokenRefresh,
    signal,
  });
};

export const getTokenRefreshCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tokenRefreshCreate>>,
    TError,
    { data: NonReadonly<TokenRefresh> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof tokenRefreshCreate>>,
  TError,
  { data: NonReadonly<TokenRefresh> },
  TContext
> => {
  const mutationKey = ['tokenRefreshCreate'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tokenRefreshCreate>>,
    { data: NonReadonly<TokenRefresh> }
  > = (props) => {
    const { data } = props ?? {};

    return tokenRefreshCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type TokenRefreshCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof tokenRefreshCreate>>
>;
export type TokenRefreshCreateMutationBody = NonReadonly<TokenRefresh>;
export type TokenRefreshCreateMutationError = unknown;

export const useTokenRefreshCreate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tokenRefreshCreate>>,
      TError,
      { data: NonReadonly<TokenRefresh> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tokenRefreshCreate>>,
  TError,
  { data: NonReadonly<TokenRefresh> },
  TContext
> => {
  const mutationOptions = getTokenRefreshCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve a list of users
 */
export const userList = (signal?: AbortSignal) => {
  return axiosInstance<CustomUser[]>({ url: `/user/`, method: 'GET', signal });
};

export const getUserListQueryKey = () => {
  return [`/user/`] as const;
};

export const getUserListQueryOptions = <
  TData = Awaited<ReturnType<typeof userList>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userList>>> = ({
    signal,
  }) => userList(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserListQueryResult = NonNullable<
  Awaited<ReturnType<typeof userList>>
>;
export type UserListQueryError = unknown;

export function useUserList<
  TData = Awaited<ReturnType<typeof userList>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userList>>,
          TError,
          Awaited<ReturnType<typeof userList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserList<
  TData = Awaited<ReturnType<typeof userList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userList>>,
          TError,
          Awaited<ReturnType<typeof userList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUserList<
  TData = Awaited<ReturnType<typeof userList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useUserList<
  TData = Awaited<ReturnType<typeof userList>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUserListQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
